#' Retrieve forest vegetation polygons around an area
#'
#' @param x `sf` or `sfc`; Geometry located in France.
#'
#' @return An `sf` object containing forest vegetation polygons
#'
#' @details
#' The function retrieves the IGN forest mask layer within a 1000 m
#' convex buffer around `x`. Retrieved polygons are then intersected
#' with a 1500 m convex buffer, cast to polygons, and normalized.
#'
#' If no forest data are found, the function returns an empty
#' `sf` object with a standardized structure.
#'
#' @export
get_vege_poly <- function(x) {

  crs <- 2154
  layer <- "IGNF_MASQUE-FORET.2021-2023:masque_foret"
  x <- sf::st_transform(x, crs)

  # standardized field names
  type <- seq_field("type")$name
  name <- seq_field("name")$name
  source <- seq_field("source")$name

  # Fetching data in 1000m distance, then crop to 1500m for large data
  fetch_envelope   <- envelope(x, 1000)
  control_envelope <- envelope(x, 1500)

  # forest mask
  forest_mask <- quiet(happign::get_wfs(
    x = fetch_envelope, layer = layer, spatial_filter = "intersects"
    ))

  if (is.null(forest_mask)) {
    cli::cli_warn("No vegetation data found. Empty {.cls sf} is returned.")
    empty_sf <- create_empty_sf("POLYGON") |> seq_normalize("vct_poly")
    return(invisible(empty_sf))
  }

  forest_mask <- sf::st_transform(forest_mask, crs)
  forest_intersect <- sf::st_intersection(forest_mask, control_envelope) |> suppressWarnings()

  # Intersection create mixed geometry type (POLYGON, MULTIPOLYGON)
  # Because st_cast cannot deal with mixed geometry, first is casted to multipoly, then poly
  vege_poly <- sf::st_cast(forest_intersect, "MULTIPOLYGON") |>
    st_cast("POLYGON", warn = FALSE) |>
    seq_normalize("vct_poly")

  vege_poly[[type]]   <- "FOR"
  vege_poly[[source]] <- "ignf_masque_foret"

  return(invisible(vege_poly))

}

#' Retrieve forest vegetation lines around an area
#'
#' @inheritParams get_vege_poly
#'
#' @return An `sf` object containing forest vegetation line features.
#'
#' @details
#' The function derives forest vegetation linear features from
#' vegetation polygons obtained with `get_vege_poly()`.
#'
#' Polygons are dissolved with a tolerance of 5 meters, converted
#' to linear geometries, and intersected with a 1499 m convex buffer
#' around `x`. Resulting geometries are cast to `LINESTRING` and
#' normalized.
#'
#' If no vegetation polygons are available, the function returns
#' an empty standardized `sf` object.
#'
#' @seealso get_vege_poly
#'
#' @export
get_vege_line <- function(x) {

  # convex buffer
  convex1499 <- envelope(x, 1499)

  # empty sf
  vege_line <-  create_empty_sf("LINESTRING") |>
    seq_normalize("vct_line")

  # standardized field names
  type <- seq_field("type")$name
  name <- seq_field("name")$name
  source <-  seq_field("source")$name

  # retrieve vegetation polygons
  vege_poly <- get_vege_poly(x)

  if (!is.null(vege_poly) && nrow(vege_poly) > 0) {

    line <- dissolve(vege_poly, tol = 5) |>
      poly_to_line() |>
      sf::st_intersection(convex1499)|>
      sf::st_cast("LINESTRING") |>
      quiet()

    line <- line[, setdiff(names(line), names(convex1499))] |>
      seq_normalize("vct_line")

    line[[type]]   <- "FOR"
    line[[source]] <- "IGNF_MASQUE-FORET"

    vege_line <- rbind(vege_line, line)
  }

  invisible(vege_line)
}

#' Generate vegetation point features around an area
#'
#' @param x An `sf` object used as the input area.
#'
#' @return An `sf` object of type `POINT` containing vegetation point
#'   features with standardized Sequoia fields, including:
#'   * `TYPE` — Vegetation type code derived from BDTOPO nature values:
#'     - `FFF` = Closed deciduous forest
#'     - `FFM` = Closed mixed forest
#'     - `FFC` = Closed coniferous forest
#'     - `FOI` = Open forest
#'     - `PEU` = Poplar plantation
#'     - `BOI` = Woodland
#'     - `LAN` = Woody heath
#'     - `HAI` = Hedge
#'     - `VER` = Orchard
#'     - `VEG` = Other vegetation types
#'   * `SOURCE` — Data source (`IGNF_BDTOPO_V3`)
#'
#' @details
#' The function retrieves BDTOPO vegetation areas (`zone_de_vegetation`)
#' within a 1000 m convex buffer around `x`. Each polygon is classified
#' into a standardized vegetation type based on its original
#' `nature` attribute.
#'
#' Vegetation polygons are then intersected with a 1500 m convex buffer,
#' cast to polygons, normalized, and filtered to exclude woody heath (`LAN`)
#' and hedges (`HAI`).
#'
#' Vegetation points are generated by spatial sampling using a hexagonal
#' pattern, with one point per 4 hectares of vegetation area. Sampled
#' points are spatially joined to vegetation attributes and clipped to
#' a 1499 m convex buffer.
#'
#' If no vegetation areas are found, the function returns an empty
#' standardized `sf` object of type `POINT`.
#'
#' @seealso get_vege_poly, get_veg_line
#'
#' @export
get_vege_point <- function(x){

  # convex buffer
  convex1000 <- envelope(x, 1000)
  convex1500 <- envelope(x, 1500)
  convex1499 <- envelope(x, 1499)

  # empty sf
  vege_point <-  create_empty_sf("POINT") |>
    seq_normalize("vct_point")

  # standardized field names
  type <- seq_field("type")$name
  name <- seq_field("name")$name
  source <-  seq_field("source")$name

  # vege
  zone_vege <- get_topo(convex1000, "BDTOPO_V3:zone_de_vegetation")

  if(!(is.null(zone_vege))){

    # type table
    nature_vals <- c("For\u00eat ferm\u00e9e de feuillus",
                     "For\u00eat ferm\u00e9e mixte",
                     "For\u00eat ferm\u00e9e de conif\u00e8res",
                     "For\u00eat ouverte",
                     "Peupleraie",
                     "Bois",
                     "Lande ligneuse",
                     "Haie",
                     "Verger")

    type_vals   <- c("FFF", "FFM", "FFC", "FOI", "PEU", "BOI", "LAN", "HAI", "VER")

    i <- match(zone_vege$nature, nature_vals)

    # type
    zone_vege[[type]] <- ifelse(is.na(i), "VEG", type_vals[i])
    zone_vege[[source]] <- "IGNF_BDTOPO_V3"

    # geometry processing
    zone_vege <- sf::st_intersection(zone_vege, convex1500) |>
      sf::st_cast("POLYGON") |>
      quiet() |>
      subset(!get(type) %in% c("LAN", "HAI"))

    # point
    n_points <- sum(round(as.numeric(sf::st_area(zone_vege)) / 40000))
    if (n_points > 0) {
      point <- sf::st_sf(sf::st_sample(zone_vege, n_points, type = "hexagonal")) |>
        sf::st_join(zone_vege, join = sf::st_intersects) |>
        sf::st_intersection(convex1499) |>
        quiet()
    }
    sf::st_geometry(point) <- "geometry"

    point <- point[, setdiff(names(point), names(convex1500))] |>
      seq_normalize("vct_point")

    vege_point <- rbind(vege_point, point)
  }

  invisible(vege_point)
}

#' Generates vegetation polygon, line and point layers for a Sequoia project.
#'
#' This function is a convenience wrapper around [get_vege_poly()],
#' [get_vege_line()] and [get_vege_point()], allowing the user to download
#' all products in one call and automatically write them to the project
#' directory using [seq_write()].
#'
#' @param dirname `character` Path to the directory. Defaults to the current
#' working directory.
#' @inheritParams seq_write
#'
#' @details
#' Each vegetation layer is always written to disk using [seq_write()],
#' even when it contains no features (`nrow == 0`).
#'
#' Informational messages are displayed to indicate whether a layer
#' contains features or is empty.
#'
#' @return A named list of file paths written by [seq_write()],
#' one per vegetation layer.
#'
#' @seealso
#' [get_vege_poly()], [get_vege_line()], [get_vege_point()],
#' [seq_write()]
#'
seq_vege <- function(
    dirname = ".",
    verbose = TRUE,
    overwrite = FALSE
) {

  # read PARCA
  f_parca <- read_sf(get_path("v.seq.parca.poly", dirname = dirname))
  f_id <- get_id(dirname)

  id <- seq_field("identifiant")$name

  # create empty path list
  path <- list()

  # hydro layer specifications
  layers <- list(
    poly  = list(fun = get_vege_poly,  key = "v.vege.poly", geom = "POLYGON"),
    line  = list(fun = get_vege_line,  key = "v.vege.line", geom = "LINESTRING"),
    point = list(fun = get_vege_point, key = "v.vege.point", geom = "POINT")
  )

  for (k in names(layers)) {

    f <- layers[[k]]$fun(f_parca)

    if (nrow(f)>0){
      f[[id]]<- f_id

      geom_union <- sf::st_union(f_parca)
      f <- quiet(sf::st_difference(f, geom_union))
      f <- quiet(sf::st_cast(f, layers[[k]]$geom))
    }

    f_path <- quiet(seq_write(
      f,
      layers[[k]]$key,
      dirname = dirname,
      verbose = FALSE,
      overwrite = overwrite
    ))

    path <- c(path, f_path)

    if (verbose) {
      if (nrow(f) == 0) {
        cli::cli_alert_info(
          c("i" = "Vege {.field {k}} layer written (empty layer)")
        )
      } else {
        cli::cli_alert_success(
          "Vege {.field {k}} layer written with {nrow(f)} feature{?s}"
        )
      }
    }
  }

  return(invisible(path))
}
