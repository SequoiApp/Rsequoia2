#' Retrieve forest vegetation polygons around an area
#'
#' @param x An `sf` object used as the input area.
#'
#' @return An `sf` object containing forest vegetation polygons with
#'   standardized fields, including:
#'   * `TYPE` — Vegetation type
#'     - `FOR` = Forest
#'   * `ORIGIN` — Source of the data (`IGNF_MASQUE-FORET`)
#'
#' @details
#' The function retrieves the IGN forest mask layer within a 1000 m
#' convex buffer around `x`. Retrieved polygons are then intersected
#' with a 1500 m convex buffer, cast to polygons, and normalized.
#'
#' If no forest data are found, the function returns an empty
#' `sf` object with a standardized structure.
#'
#' @export
get_vege_poly <- function(x) {

  # convex buffers
  convex1000 <- buffer_to_convex(x, 1000)
  convex1500 <- buffer_to_convex(x, 1500)

  # empty sf
  vege_poly <-  create_empty_sf("POLYGON") |>
    seq_normalize("vct_poly")

  # standardized field names
  type <- seq_field("type")$name
  name <- seq_field("name")$name
  source <-  seq_field("source")$name

  # forest mask
  forest_mask <- get_topo(convex1000, "IGNF_MASQUE-FORET.2021-2023:masque_foret")

  if(!(is.null(forest_mask))){
    forest_mask[[type]]   <- "FOR"
    forest_mask[[source]] <- "IGNF_MASQUE-FORET"

    forest_mask <- suppressWarnings(
      sf::st_intersection(forest_mask, convex1500) |>
        sf::st_cast("POLYGON") |>
        seq_normalize("vct_poly")
    )

    vege_poly <- rbind(vege_poly, forest_mask)
  }

  invisible(vege_poly)
}

#' Retrieve forest vegetation lines around an area
#'
#' @param x An `sf` object used as the input area.
#'
#' @return An `sf` object containing forest vegetation line features
#'   with standardized fields, including:
#'   * `TYPE` — Vegetation type
#'     - `FOR` = Forest
#'   * `SOURCE` — Data source (`IGNF_MASQUE-FORET`)
#'
#' @details
#' The function derives forest vegetation linear features from
#' vegetation polygons obtained with `get_vege_poly()`.
#'
#' Polygons are dissolved with a tolerance of 5 meters, converted
#' to linear geometries, and intersected with a 1499 m convex buffer
#' around `x`. Resulting geometries are cast to `LINESTRING` and
#' normalized.
#'
#' If no vegetation polygons are available, the function returns
#' an empty standardized `sf` object.
#'
#' @seealso get_vege_poly
#'
#' @export
get_vege_line <- function(x) {

  # convex buffer
  convex1499 <- buffer_to_convex(x, 1499)

  # empty sf
  vege_line <-  create_empty_sf("LINESTRING") |>
    seq_normalize("vct_line")

  # standardized field names
  type <- seq_field("type")$name
  name <- seq_field("name")$name
  source <-  seq_field("source")$name

  # retrieve vegetation polygons
  vege_poly <- get_vege_poly(x)

  if (!is.null(vege_poly) && nrow(vege_poly) > 0) {
    line <- suppressWarnings(
      dissolve(vege_poly, tol = 5) |>
        poly_to_line() |>
        sf::st_intersection(convex1499)|>
        sf::st_cast("LINESTRING") |>
        seq_normalize("vct_line")
    )

    line[[type]]   <- "FOR"
    line[[source]] <- "IGNF_MASQUE-FORET"

    vege_line <- rbind(vege_line, line)
  }

  invisible(vege_line)
}

#' Generate vegetation point features around an area
#'
#' @param x An `sf` object used as the input area.
#'
#' @return An `sf` object of type `POINT` containing vegetation point
#'   features with standardized Sequoia fields, including:
#'   * `TYPE` — Vegetation type code derived from BDTOPO nature values:
#'     - `FFF` = Closed deciduous forest
#'     - `FFM` = Closed mixed forest
#'     - `FFC` = Closed coniferous forest
#'     - `FOI` = Open forest
#'     - `PEU` = Poplar plantation
#'     - `BOI` = Woodland
#'     - `LAN` = Woody heath
#'     - `HAI` = Hedge
#'     - `VER` = Orchard
#'     - `VEG` = Other vegetation types
#'   * `SOURCE` — Data source (`IGNF_BDTOPO_V3`)
#'
#' @details
#' The function retrieves BDTOPO vegetation areas (`zone_de_vegetation`)
#' within a 1000 m convex buffer around `x`. Each polygon is classified
#' into a standardized vegetation type based on its original
#' `nature` attribute.
#'
#' Vegetation polygons are then intersected with a 1500 m convex buffer,
#' cast to polygons, normalized, and filtered to exclude woody heath (`LAN`)
#' and hedges (`HAI`).
#'
#' Vegetation points are generated by spatial sampling using a hexagonal
#' pattern, with one point per 4 hectares of vegetation area. Sampled
#' points are spatially joined to vegetation attributes and clipped to
#' a 1499 m convex buffer.
#'
#' If no vegetation areas are found, the function returns an empty
#' standardized `sf` object of type `POINT`.
#'
#' @seealso get_vege_poly, get_veg_line
#'
#' @export
get_vege_point <- function(x){

  # convex buffer
  convex1000 <- buffer_to_convex(x, 1000)
  convex1500 <- buffer_to_convex(x, 1500)
  convex1499 <- buffer_to_convex(x, 1499)

  # empty sf
  vege_point <-  create_empty_sf("POINT") |>
    seq_normalize("vct_point")

  # standardized field names
  type <- seq_field("type")$name
  name <- seq_field("name")$name
  source <-  seq_field("source")$name

  # vege
  zone_vege <- get_topo(convex1000, "BDTOPO_V3:zone_de_vegetation")

  if(!(is.null(zone_vege))){

    # type table
    nature_vals <- c("For\u00eat ferm\u00e9e de feuillus",
                     "For\u00eat ferm\u00e9e mixte",
                     "For\u00eat ferm\u00e9e de conif\u00e8res",
                     "For\u00eat ouverte",
                     "Peupleraie",
                     "Bois",
                     "Lande ligneuse",
                     "Haie",
                     "Verger")

    type_vals   <- c("FFF", "FFM", "FFC", "FOI", "PEU", "BOI", "LAN", "HAI", "VER")

    i <- match(zone_vege$nature, nature_vals)

    # type
    zone_vege[[type]] <- ifelse(is.na(i), "VEG", type_vals[i])
    zone_vege[[source]] <- "IGNF_BDTOPO_V3"

    # geometry processing
    zone_vege <- sf::st_intersection(zone_vege, convex1500) |>
      sf::st_cast("POLYGON") |>
      suppressWarnings() |>
      seq_normalize("vct_point") |>
      subset(!get(type) %in% c("LAN", "HAI"))

    # point
    n_points <- sum(round(as.numeric(sf::st_area(zone_vege)) / 40000))
    if (n_points > 0) {
      point <- sf::st_sf(sf::st_sample(zone_vege, n_points, type = "hexagonal")) |>
        sf::st_join(zone_vege, join = sf::st_intersects) |>
        sf::st_intersection(convex1499) |>
        suppressWarnings()
    }
    sf::st_geometry(point) <- "geometry"

    vege_point <- rbind(vege_point, point)
  }

  invisible(vege_point)
}
